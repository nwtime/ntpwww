---
title: "PPSAPI Interface for Precision Time Signals"
type: archives
---

![gif](/archives/pic/tonea.gif)[from _NBS Special Publication 432, 1979_](/reflib/pictures) (out of print)

Last update: 10-Mar-2014 05:10 UTC

* * *

#### Table of Contents

*   [Introduction](/archives/4.2.8-series/kernpps/#introduction)
*   [PPSAPI Application Program Interface](/archives/4.2.8-series/kernpps/#ppsapi-application-program-interface)

* * *

#### Introduction

RFC-2783 describes the PPSAPI application programming interface for external precision time signals, such as the pulse-per-second (PPS) signal generated by some radio clocks and cesium oscillators. The PPSAPI provides a generic capability in the ubiquitous Unix kernel which can be used for a wide variety of measurement applications, including network time synchronization and related experiments. The hardware to do this requires only a serial port and a modem control lead, such as the data carrier detect (DCD) lead, which can be driven by an external source via a level converter/pulse generator such as described on the [Pulse-per-second (PPS) Signal Interfacing](/archives/4.2.8-series/pps) page. In some systems a parallel port can be used for the same purpose.

The PPSAPI interface defined in RFC-2783 is the only PPS interface supported in NTP Version 4. The PPSAPI is supported in stock FreeBSD and, with the addition of the <code>PPSkit</code> kernel module, in Linux.

The special header file <code>/usr/include/sys/timepps.h</code> implements the PPSAPI using whatever primitives are available in each archeticture and operating system. It obsoletes previous APIs based on the <code>tty_clock</code> and <code>ppsclock</code> line disciplines and streams modules, which are no longer supported.

The [PPS Clock Discipline](/archives/drivers/driver22) driver (type 22) uses the PPSAPI in conjunction with a local radio clock or remote NTP server as a reference clock. The driver can also use the PPSAPI as an interface directly to the kernel PPS facility as described on the [Kernel Model for Precision Timekeeping](/archives/4.2.8-series/kern) page.

* * *

#### PPSAPI Application Program Interface

The PPSAPI interface provides the following functions:

<code>**time_pps_create**</code>

: Creates a PPS interface instance and returns a handle to it.

<code>**time_pps_destroy**</code>

: Destroys a PPS interface and returns the resources used.

<code>**time_pps_setparams**</code>

: Sets the parameters associated with a PPS interface instance, including offsets to be automatically added to captured timestamps.

<code>**time_pps_getparams**</code>

: Returns the parameters associated with a PPS interface instance.

<code>**time_pps_getcap**</code>

: Returns the capabilities of the current interface and kernel implementation.

<code>**time_pps_fetch**</code>

: Returns the current timestamps associated with a PPS interface instance in either nanoseconds and nanoseconds (Unix <code>timespec</code>) or seconds and fraction (NTP) format.

<code>**time_pps_kcbind**</code>

: If kernel PPS processing is supported, this binds the support to the associated PPS interface instance.

The entire PPS interface functionality is currently provided by inline code in the <code>timepps.h</code> header file. While not all implementations support the full PPSAPI specification, they do support all the functions required for the PPS driver described next. The FreeBSD, Linux and Solaris implementations can be used with the stock kernels provided with those systems; however, the Tru64 and SunOS kernels require additional functions not provided in the stock kernels. Solaris users are cautioned that these functions operate improperly in Solaris versions prior to 2.8 with patch Generic_108528-02. Header files for other systems can be found via the web at [nanokernel.tar.gz](/reflib/software/nanokernel.tar.gz).